# McAfee Demo
This demo shows how to use the FluentBit Structured DDS plug-in to publish scan results from McAfee over DDS using a data model that is designed to insert data into [Splunk CIM for Malware](https://docs.splunk.com/Documentation/CIM/4.14.0/User/Malware).

---
## Files in this example:
   * `SplunkMalware.xml`: contains the XML full representation of the published type, 
including comments and annotations on the fields.

   * `McafeePublisher.xml`: this is the file containing the description of the domain and the declaration
of the entities used by the FluentBit DDS Publisher. In particular, this file, declares 
the following entities:
       * Domain participant: `MalwareParticipantLibrary::MalwareParticipant`
       * Data Writer: `MalwarePublisher::MalwareWriter`

   The above names are referenced in the DDS Plugin configuration file.

   * `McafeePublisher.rtisdproj`: the [RTI System Designer](https://community.rti.com/downloads/experimental/system-designer) project file

   * `mcafee.log`: a sample output file generated by the McAfee scanner.

   * `mcafee.conf`: the FluentBit master configuration file

   * `mcafee-parser.conf`: the FluentBit parser configuration file containing all the `[PARSER]` sections with the rules to extract the fields from the input log file

   * `mcafee-malware.json`: the JSON field mapping file that describes how to map the fields extracted by the parser into the DDS type

---
## Data Model
The data model used by this example is as follow (using a compact IDL syntax without comments or [XTypes](https://www.omg.org/spec/DDS-XTypes/1.1/About-DDS-XTypes/) annotations):

```
module Common {
  struct HostIdentification {
    string<20> host;
    string<50> ip;
    string<50> name;
  };

  struct UTCTimestamp {
    uint32 sec;
    uint32 nanosec;
  };

  const uint16 HASH_STRING_MAX = 32;
  const uint16 PATH_STRING_MAX = 200;
  const uint16 EMAIL_STRING_MAX = 200;
  const uint16 USER_STRING_MAX = 40;
  const uint16 URL_STRING_MAX = 200;
  const uint16 VENDOR_STRING_MAX = 100;
};

module Malware {
    enum Action {
      @value(1)
      Allowed,
      @value(2)
      Blocked,
      @value(3)
      Deferred
    };

    enum ControlOperation {
      @value(1)
      StartScan,
      @value(2)
      StopScan,
      @value(3)
      ScanCompleted,
      @value(4)
      ClientConnected,
      @value(5)
      ClientDisconnected,
      @value(6)
      InstalledVirusDefinition
    };
    	
    struct Attacks {
      CIM::Malware::Action  action_enum;
      string<40>            category;
      string<Common::HASH_STRING_MAX> file_hash;
      Common::UTCTimestamp  date;
      Common::HostIdentification dest;
      string<30> dest_nt_domain;
      string<Common::PATH_STRING_MAX> file_name;
      string<Common::PATH_STRING_MAX> file_path;
      string<Common::EMAIL_STRING_MAX> sender;
      string<50> signature;
      Common::HostIdentification src;
      string<Common::USER_STRING_MAX> user;
      string<Common::URL_STRING_MAX> url;
      string<Common::VENDOR_STRING_MAX> vendor_product;
    };
    
    struct Operations {
      CIM::Malware::ControlOperation op;
      Common::HostIdentification dest;
      string<30> dest_nt_domain;
      string<50> product_version;
      string<50> signature_version;
      string<Common::VENDOR_STRING_MAX> vendor_product;
    };

    union Event switch(CIM::Malware::EventKind) {
      case MalwareEvent_Attack:    CIM::Malware::Attacks attack;
      case MalwareEvent_Operation: CIM::Malware::Operations operation;
    };

```



-------
## FluentBit Configuration
The FluentBit master configuration described in `mcafee.conf` creates three inputs
that are used to identify different type of messages from a McAfee
log output:

   * Start messages: an entry line that signal the beginning of the scan operation. 
     Start messages are tagged with `mcafee.start` and are processed by the `beginLine`
     parser. The parser identify the fields from lines that have the following
     format:

```
Oct 01 00:16:03 ubuntu INFO OASManager [27304] Starting OAS Manager
```

   * Error messages: this input is used to detect lines representing scanning
     errors. Errors are tagged with `mcafee.error` and are processed by the `skipFile` 
     parser. The parser identify the fields from the following lines:

```
Oct 01 11:25:20 ubuntu ERROR AMOASScanner [27304] Skipping since file path /tmp/pip-unpack-JXnqx7/enum34-1.1.6-py2-none-any.whl could not be opened due to - No such file or directory
```

   * Infection messages: this input is used to identify lines that are generated
     when the scanner detects an infected file. Those messages are tagged with
     the tag `mcafee.found` and are processed by the parser `foundVirus`.
     The structure of this line is:

```
Oct 01 10:33:35 ubuntu ERROR AMOASScanner [27304] Infection caught File Name: /home/jason/Desktop/malware/G1_718c6e47512bec8c585320d087041ace.bin Fil
e Size: 28160 Infection Name: BackDoor-FBPA Time: 1569951215 Process Name: /usr/bin/scp User Name: root Profile Type: 1
```

All the three inputs reads the data from a file called 'log.txt'. The file does
not exist in this example directory as it need to be created dynamically just like 
you would get it from running the McAfee scanner. See the next section (Running the test)
for additional information on how to dynamically simulate this input file from a sample log.

Having three inputs that operates on the same file, will cause duplication of 
the same events. Each input produces two kind of events:

   * Fully parsed events (when the provided parser is able to identify and 
     dissect the message
   * Unparsed events. Those are automatically generated by the input plugin. 
     They are composed by a single field called "log" that contains the entire
     log line that does not match the parser regex (this field can be configured
     through the Tail configuration parameter `Key`).

### The filter block
The configuration file also defines a **grep filter** with the following rule:

```
[FILTER]
    Name    grep
    Match   mcafee.*
    Exclude log ^.+$
```
This filter is used to construct a pipeline of events without unparsed events, with
all the recognized messages with the right tag

When the Tail Input process a line that the parser is not able to understand,
it inserts the event in the pipeline using the
field 'log' to store the full unrecognized log message (see help page for the
Tail input).

This filter, applied to all the inputs (Match is `mcafee.*`), removes all the 
messages not recognized by each input parser from each input. After this filter
all the unparsed lines are dropped.

Take for example the first input (Tail input with `Parser=beginLine`) that 
recognizes only the line that says "Starting OAS Manager". 
All the other lines of this parser are not recognized but they are still
inserted as events with a single "log" field. 
Thanks to this filter, all those lines are removed and this input is then
able to produce **only** one events with the tag 'mcafee.start'.

After the filter the events processed by the next nodes in the pipeline (Buffer)
are only the recognized ones, and each one have the correct tag:

   * Start line: `mcafee.start`
   * Error accessing a file: `mcafee.error`
   * Infection detected: `mcafee.found`


### The Output
This example uses the RTI Connext DDS Structured output Plug-in (installed by default 
under `/usr/local/lib/flb-out_dds_str.so`). This plug-in is configured in the
following section of the `mcafee.conf` file:

```
[OUTPUT]
    Name  dds_str
    Match mcafee.*

    # dds_str configuration 
    # XMLFile is optional, if not provided will use the default user's qos search path
    # You can use either XMLFile or if you need to load multiple files, 
    # use XMLFile_xx where xx is 0-9.
    # Numbers must be contiguous
    XMLFile_0   McafeePublisher.xml
    XMLFile_1   SplunkMalware.xml

    # Mandatory parameters
    DomainParticipant   MalwareParticipantLibrary::MalwareParticipant
    DataWriter          MalwarePublisher::MalwareWriter

    # The default is 'warn'. Possible values are 'none', 'warn', 'warn_once', 'abort'
    PrecisionLossAction warn

    # The JSON File containing the mapping between keys and DDS types for the given topic
    TypeMap ./mcafee-malware.json
```



| Property              | Description                                                  |
| --------------------- | ------------------------------------------------------------ |
| `Name`                | Identify the name of the output plug-in. This name must be exactly `dds_str` as it must match the name of the `.so` containing the plugin. |
| `Match`               | Matching rule, in this case we want to send all the events with  tag starting with `mcafee`. |
| `XMLFile_0`           | Tells the plug-in to load the file `McafeePublisher.xml` containing the domain and participant library definitions. |
| `XML_File_1`          | Tells the plug-in to load the file `SplunkMalware.xml` containing the DDS Types definitions. |
| `DomainParticipant`   | The name of the fully qualified participant as defined in `McafeePublisher.xml` (in this case: `MalwareParticipantLibrary::MalwareParticipant`). |
| `DataWriter`          | The name of the fully qualified data writer as defined in `McafeePublisher.xml` (in this case: `MalwarePublisher::MalwareWriter`). |
| `PrecisionLossAction` | What to do in case of precision loss is to produce a warning message in the FluentBit log every time a loss is detected. |
| `TypeMap`             | Defines the file `./mcafee-malware.json` map file            |



The TypeMap file `mcafee-malware.json` describes how to map the fields of all the events processed by this output plug-in into members of the data type used by the specified data writer. 

In our case the XML configuration `McafeePublisher.xml` defines the data writer 
`MalwarePublsher::MalwareWriter` to publish on topic `MalwareAttacks` of type `CIM::Malware::Attacks` (see the IDL definition at the beginning of this document). 

The current mapping file contains a single table for events with tag: `mcafee.found` and operates as 
follow:

| FluentBit field | CIM::Malware::Attacks member |
| --------------- | ---------------------------- |
| `hostname`      | `dest.host`                  |
| `appName`       | `vendor_product`             |
| `filepath`      | `file_path`                  |
| `virusname`     | `signature`                  |
| `scantime`      | `date.sec`                   |
| `filename`      | `file_name`                  |
| `username`      | `user`                       |

It also statically assign the following values:

| CIM::Malware::Attacks member | Value       |
| ---------------------------- | ----------- |
| `action_enum`                | 2 (Blocked) |
| `date.nanosecond`            | 0           |

<br/><br/>

---
## Running the test

To run the tests, open 3 terminals (in this order):
   * Terminal 1: run FluentBit to publish over DDS the parsed scan results
   * Terminal 2: run RTI Connext DDS "Spy" utility to view in real time the published data
   * Terminal 3: simulate the generation of the scan log file

<br/><br/>

### Terminal 1: Run FluentBit

First of all, make sure you have ConnextDDS environment variable correctly set (by default the Fluent Bit DDS plugin is dynamically linked to ConnextDDS library, so you need to have the `LD_LIBRARY_PATH` correctly set. 
If you built the Fluent Bit DDS Plugins using static libraries, you don't need this step). Refer to Connext DDS User's manual to set up your environment.

To run FluentBit, first make sure the input file (`log.txt`) exist (empty), then launch FluentBit specifying the DDS Structured output plugin and the`mcafee.conf` configuration:
```
$ rm ./log.txt
$ touch ./log.txt
$ fluent-bit -e /usr/local/lib/flb-out_dds_str.so -c mcafee.conf
```

<br/><br/>

### Terminal 2: Receive the data

To verify that the data is correctly published over RTI Connext DDS, use the utility `rtiddsspy` (included in the RTI Connext distribution DDS) to subscribe and print to console:

```
rtiddsspy -domain 0 -printSample
```

<br/><br/>

### Terminal 3: Produce the data

If you don't have McAfee available, you can use the provided sample file (`mcafee.log`), with the `catdelay` utility (included in the example folder). The catdelay is a small C program (included under `examples/catdelay` that reads one line at the time from a file and prints it to stdout with a given delay. This will allow the simulation of the creation of the log file (`log.txt` as used by the
three input plug-ins of FluentBit). If you have not done it before, build the `catdelay` utility just by invoking:

```
gcc -o catdelay ../catdelay/catdelay.c
```

Then copy the binary in a directory that is already included in your search path, for example `/usr/local/bin`:

```
sudo cp catdelay /usr/local/bin
```

Then from one terminal start the `simulate-loop.sh` that launch `catdelay` to produce the file `log.txt` from `mcafee.log` at a rate of 4 lines per second:

```
./simulate-loop.sh
```

As soon as you press ENTER to start the generation (prompted by the script), FluentBit (Terminal 1) should log messages showing the messages being parsed and processed.

From the Terminal 2 (the one running `rtiddsspy`) you should see the published data with the malware information:

```
1575573721.001083  d +M  C0A8129A    MalwareAttacks      CIM_Malware_Attack
                                ...                      s                 
action_enum: Blocked
category: NULL
date: 
   sec: 1569951216
   nanosec: 0
dest: 
   host: "ubuntu"
   ip: NULL
   name: NULL
dest_nt_domain: NULL
file_hash: NULL
file_name: NULL
file_path: "/home/jason/Desktop/malware/G2_0f171ff1a80822934439edaa7be1023b.bin"
sender: NULL
signature: "PUP-FGB"
src: NULL
user: "root"
url: NULL
vendor_product: "AMOASScanner"
```












